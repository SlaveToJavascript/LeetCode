# https://leetcode.com/problems/factorial-trailing-zeroes/description/
# MEDIUM
# Tags: mathlc, #172

# GIVEN:
    # an integer, n

# TASK:
    # return the number of trailing zeroes in n!

# EXAMPLES:
    # Input: n = 3
    # Output: 0
    # Explanation: 3! = 6, no trailing zero.

    # Input: n = 5
    # Output: 1
    # Explanation: 5! = 120, one trailing zero.

    # Input: n = 0
    # Output: 0

###########################################################################################################

# âœ… ALGORITHM: DIVIDE N BY 5^x (LOGARITHMIC TIME COMPLEXITY)
# In the multiplication process to get factorial result, trailing 0's are generated by the product of 5 or its multiples, such as 10, 15, 20, and so on
# Initially, it seems like we can simply return num/5 to count the number of trailing zeroes
# but this approach fails when we encounter numbers like 25, 125, 625, etc.
    # e.g. when we do 25/5, we only consider dividing by 1 factor of 5 (i.e. 5^1), but actual no. of trailing 0's = 6 (25 = 5 * 5)
    # To account for this, we need to divide by 5 and then by 25
    # i.e. we need to loop and divide the number by increasing powers of 5 (i.e. 5^1, 5^2, 5^3, ...) until the division result is less than 5

# TIME COMPLEXITY: O(log_5 n) = O(log n)
    # since we're incrementally dividing n by powers of 5
# SPACE COMPLEXITY: O(1)

import math

def trailingZeroes(n):
    zeroes_count = 0 # return value
    divisor = 5 # start divisor as 5^1, then increase to 5^2, 5^3 and so on if necessary

    while divisor <= n: # e.g. if divisor = 25 and n = 25, we should still go into the iteration
        zeroes_count += n // divisor
        divisor *= 5 # divisor becomes the next factor of 5 (e.g. 5^1 -> 5^2)
    
    return zeroes_count